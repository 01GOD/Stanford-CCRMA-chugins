//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"
#include "chuck_ugen.h"
#include "chuck_type.h"
#include "chuck_vm.h"
#include "chuck_instr.h"
#include "chuck_errmsg.h"

// general includes
#include <stdio.h>
#include <limits.h>
#include <iostream>

// declaration of chugin constructor
CK_DLL_CTOR(patch_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(patch_dtor);

// example of getter/setter
CK_DLL_MFUN(patch_setParam);
CK_DLL_MFUN(patch_getParam);

CK_DLL_MFUN(patch_connect);
CK_DLL_MFUN(patch_gain);
CK_DLL_MFUN(patch_method);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(patch_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT patch_data_offset = 0;

// class Derived : virtual public Chuck_Instr_Reg_Push_Deref2 {};

// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
class Patch
{
public:
    // constructor
    Patch( t_CKFLOAT fs)
    {
        m_param = 0;
    }

    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        // default: this passes whatever input is patched into Chugin
        t_CKFLOAT val = (t_CKFLOAT)in;
        Chuck_DL_Return ret;

        // these three lines took a very long time to figure out...
        Chuck_VM_Code* func = m_func->code;
        // cast the function as a dynamically-linked member func
        f_mfun f = (f_mfun)func->native_func;
        // call said function
        f((Chuck_Object*)(m_dest), &val, &ret, m_vm, m_shred, m_api); // api?

        return in;
    }

    // set parameter example
    t_CKFLOAT setParam( t_CKFLOAT p )
    {
        m_param = p;
        return p;
    }

    // set parameter example
    void connect( Chuck_UGen* dest, std::string method, Chuck_VM* vm, Chuck_VM_Shred* shred, CK_DL_API api)
    {
      // TODO check if null
      m_dest = dest;
      m_vm = vm;
      m_api = api;
      std::cout << "going to connect dest" << std::endl;
      std::cout << "SHRED: " << shred << std::endl;

      m_shred = shred;

      Chuck_Func * found = NULL;

      for(int i = 0; i < dest->vtable->funcs.size(); i++)
      {
        Chuck_Func * func = dest->vtable->funcs[i];

        // funcs can be overwritten or have multiple defn, look for the right one
        if (func->base_name == method && 
            func->def->arg_list != NULL &&
            // we only want funcs with one arg
            func->def->arg_list->next == NULL &&
            // ensure arg is float
            func->def->arg_list->type == shred->vm_ref->env()->t_float) 
        {
            std::cout << "Found func: " << func->name << std::endl;
            found = func;
            break;
        }
      }

      if (!found) {
          std::cerr << "Patch.connect(): unable to find method " << method << std::endl;
          return;
      }

      Chuck_Func* curr = found;
      // traverse overloads to find top of stack
      while (curr->next != NULL) {
          if (curr->def->arg_list != NULL &&
              // we only want funcs with one arg
              curr->def->arg_list->next == NULL &&
              // ensure arg is float
              curr->def->arg_list->type == shred->vm_ref->env()->t_float) 
          {
              std::cout << "Found being overloaded: " << curr->name << std::endl;
              found = curr;
          }
          curr = curr->next;
      }

      std::cout << "found finished: " << found->name << std::endl;
      m_func = found;

      return;
    }

    // get parameter example
    t_CKFLOAT getParam() { return m_param; }
    std::string getMethod() { return m_func->base_name; 
    }
    
private:
    // instance data
    t_CKFLOAT m_param;
    Chuck_UGen* m_dest;
    Chuck_VM_Shred* m_shred;
    Chuck_VM* m_vm;
    Chuck_Func* m_func;
    CK_DL_API m_api;

    // given a name from a Chuck_Func, retrieve the base name
    // e.g. "dump@0@Object" -> "dump"
    // this is needed because base_name isn't being set?
    std::string getBaseName(std::string s) 
    {
        std::string::size_type pos = s.find('@');
        if (pos != std::string::npos)
        {
            return s.substr(0, pos);
        }
        else
        {
            return s; // TODO return error
        }
    }
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( Patch )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "Patch");
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "Patch", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, patch_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, patch_dtor);
    
    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, patch_tick, NULL, 1, 1);
    
    // NOTE: if this is to be a UGen with more than 1 channel, 
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    // example of adding setter method
    QUERY->add_mfun(QUERY, patch_setParam, "float", "param");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding setter method
    QUERY->add_mfun(QUERY, patch_gain, "float", "gain");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");


    // connect method
    QUERY->add_mfun(QUERY, patch_connect, "void", "connect");
    QUERY->add_arg(QUERY, "UGen", "dest" );
    QUERY->add_arg(QUERY, "string", "method");

    // example of adding getter method
    QUERY->add_mfun(QUERY, patch_getParam, "float", "param");

    QUERY->add_mfun(QUERY, patch_method, "string", "method");

    
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    patch_data_offset = QUERY->add_mvar(QUERY, "int", "@p_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(patch_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, patch_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    Patch * p_obj = new Patch(API->vm->get_srate(API, SHRED));
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, patch_data_offset) = (t_CKINT) p_obj;
}


// implementation for the destructor
CK_DLL_DTOR(patch_dtor)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
    // check it
    if( p_obj )
    {
        // clean up
        delete p_obj;
        OBJ_MEMBER_INT(SELF, patch_data_offset) = 0;
        p_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(patch_tick)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
 
    // invoke our tick function; store in the magical out variable
    if(p_obj) *out = p_obj->tick(in);

    // yes
    return TRUE;
}


// example implementation for setter
CK_DLL_MFUN(patch_setParam)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
    // set the return value
    RETURN->v_float = p_obj->setParam(GET_NEXT_FLOAT(ARGS));
}

// example implementation for setter
CK_DLL_MFUN(patch_gain)
{
    // get our c++ class pointer
    Patch* p_obj = (Patch*)OBJ_MEMBER_INT(SELF, patch_data_offset);
    // set the return value
    RETURN->v_float = GET_NEXT_FLOAT(ARGS);
}

// example implementation for getter
CK_DLL_MFUN(patch_getParam)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
    // set the return value
    RETURN->v_float = p_obj->getParam();
}

// get the name of the current method being patched
CK_DLL_MFUN(patch_method)
{
    Patch* p_obj = (Patch*)OBJ_MEMBER_INT(SELF, patch_data_offset);
    
    std::string method = p_obj->getMethod();
    RETURN->v_string = (Chuck_String*)API->object->create_string(API, SHRED, method);
}

// connect the ugen's method so that patch's input will set it
CK_DLL_MFUN(patch_connect)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
    Chuck_UGen * dest = (Chuck_UGen *)GET_NEXT_OBJECT(ARGS);
    Chuck_String* method = (Chuck_String*)GET_NEXT_STRING(ARGS);


    std::cout << "patch_connect " << dest->vtable->funcs.size() << std::endl;
    for (int i = 0; i < dest->vtable->funcs.size(); i++)
    {
        Chuck_Func* func = dest->vtable->funcs[i];
                  std::cout << "base name: " << func->base_name << " " << func->base_name.size() << std::endl;
                  std::cout << "name: " << func->name << std::endl;
    }

    std::cout << "patch_finished" << std::endl << std::endl;
    p_obj->connect(dest, method->str(), VM, SHRED, API);
 }
