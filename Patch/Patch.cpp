//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"
#include "chuck_ugen.h"
#include "chuck_type.h"
#include "chuck_vm.h"

// general includes
#include <stdio.h>
#include <limits.h>
#include <iostream>

// declaration of chugin constructor
CK_DLL_CTOR(patch_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(patch_dtor);

// example of getter/setter
CK_DLL_MFUN(patch_setParam);
CK_DLL_MFUN(patch_getParam);

CK_DLL_MFUN(patch_connect);
CK_DLL_MFUN(patch_gain);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(patch_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT patch_data_offset = 0;


// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
class Patch
{
public:
    // constructor
    Patch( t_CKFLOAT fs)
    {
        m_param = 0;
    }

    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        // default: this passes whatever input is patched into Chugin
        return in;
    }

    // set parameter example
    t_CKFLOAT setParam( t_CKFLOAT p )
    {
        m_param = p;
        return p;
    }

    // set parameter example
    void connect( Chuck_UGen * dest, Chuck_VM_Shred* shred)
    {
      // TODO check if null
      m_dest = dest;
      std::cout << "going to connect dest" << std::endl;
      std::cout << "SHRED: " << shred << std::endl;

      m_shred = shred;

      std::string func_name = "gain";

      Chuck_Func * found;

      for(int i = 0; i < dest->vtable->funcs.size(); i++)
      {
        Chuck_Func * func = dest->vtable->funcs[i];
        std::cout << "base name: " << func->base_name << std::endl;
        std::cout << "name: " << func->name << std::endl;

        /*
        if (func->next != NULL)  {
        // std::cout << "next->name: " << func->next->name << std::endl;
        }
        */

        // found the func we're looking for
        if (func->base_name == func_name && func->def->arg_list != NULL) {
            found = func;
            break;
        }

        // TOOD NEXT: ugen_xxx.cpp:1396 -> some vm instr should be how to call functions.

        if(func->name.find("tick") == 0 &&
            // ensure has one argument
            func->def->arg_list != NULL &&
            // ensure first argument is float
            // func->def->arg_list->type == SHRED->vm_ref->env()->t_float &&
            // ensure has only one argument
            func->def->arg_list->next == NULL
            // &&
            // ensure returns float
            // func->def->ret_type == SHRED->vm_ref->env()->t_float
            )
        {
            //std::cout << "found tick func" << std::endl;
            // break;
        }
      }

      Chuck_Func* curr = found;
      // traverse the function overloads
      while (curr->next != NULL) {
          if (curr->def->arg_list != NULL) {
              found = curr;
          }
          curr = curr->next;
      }

      std::cout << "found finished: " << found->name << std::endl;
    }
    /*
    EM_log(CK_LOG_WARNING, "ChuGen '%s' does not define a suitable tick function",
               ugen->type_ref->name.c_str());
    */

    // get parameter example
    t_CKFLOAT getParam() { return m_param; }
    
private:
    // instance data
    t_CKFLOAT m_param;
    Chuck_UGen * m_dest;
    Chuck_VM_Shred* m_shred;

    // given a name from a Chuck_Func, retrieve the base name
    // e.g. "dump@0@Object" -> "dump"
    // this is needed because base_name isn't being set?
    std::string getBaseName(std::string s) 
    {
        std::string::size_type pos = s.find('@');
        if (pos != std::string::npos)
        {
            return s.substr(0, pos);
        }
        else
        {
            return s; // TODO return error
        }
    }
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( Patch )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "Patch");
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "Patch", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, patch_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, patch_dtor);
    
    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, patch_tick, NULL, 1, 1);
    
    // NOTE: if this is to be a UGen with more than 1 channel, 
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    // example of adding setter method
    QUERY->add_mfun(QUERY, patch_setParam, "float", "param");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding setter method
    QUERY->add_mfun(QUERY, patch_gain, "float", "gain");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");


    // connect method
    QUERY->add_mfun(QUERY, patch_connect, "void", "connect");
    QUERY->add_arg(QUERY, "UGen", "dest" );

    // example of adding getter method
    QUERY->add_mfun(QUERY, patch_getParam, "float", "param");
    
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    patch_data_offset = QUERY->add_mvar(QUERY, "int", "@p_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(patch_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, patch_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    Patch * p_obj = new Patch(API->vm->get_srate(API, SHRED));
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, patch_data_offset) = (t_CKINT) p_obj;
}


// implementation for the destructor
CK_DLL_DTOR(patch_dtor)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
    // check it
    if( p_obj )
    {
        // clean up
        delete p_obj;
        OBJ_MEMBER_INT(SELF, patch_data_offset) = 0;
        p_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(patch_tick)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
 
    // invoke our tick function; store in the magical out variable
    if(p_obj) *out = p_obj->tick(in);

    // yes
    return TRUE;
}


// example implementation for setter
CK_DLL_MFUN(patch_setParam)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
    // set the return value
    RETURN->v_float = p_obj->setParam(GET_NEXT_FLOAT(ARGS));
}

// example implementation for setter
CK_DLL_MFUN(patch_gain)
{
    // get our c++ class pointer
    Patch* p_obj = (Patch*)OBJ_MEMBER_INT(SELF, patch_data_offset);
    // set the return value
    RETURN->v_float = GET_NEXT_FLOAT(ARGS);
}



// example implementation for getter
CK_DLL_MFUN(patch_getParam)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
    // set the return value
    RETURN->v_float = p_obj->getParam();
}

// example implementation for getter
CK_DLL_MFUN(patch_connect)
{
    // get our c++ class pointer
    Patch * p_obj = (Patch *) OBJ_MEMBER_INT(SELF, patch_data_offset);
    Chuck_UGen * dest = (Chuck_UGen *)GET_NEXT_OBJECT(ARGS);


    std::cout << "patch_connect " << dest->vtable->funcs.size() << std::endl;
    for (int i = 0; i < dest->vtable->funcs.size(); i++)
    {
        Chuck_Func* func = dest->vtable->funcs[i];
                  std::cout << "base name: " << func->base_name << " " << func->base_name.size() << std::endl;
                  std::cout << "name: " << func->name << std::endl;
    }

    std::cout << "patch_finished" << std::endl << std::endl;
    p_obj->connect(dest, SHRED); // need the vm shred to get stuff done
    
    // set the return value
    // RETURN->v_float = p_obj->getParam();
}
