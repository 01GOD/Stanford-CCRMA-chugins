//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"
#include "chuck_instr.h"
#include "chuck_vm.h"

// general includes
#include <stdio.h>
#include <limits.h>

// STL includes
#include <iostream>
#include <string>
using namespace std;

#if defined(__CK_SNDFILE_NATIVE__)
#include <sndfile.h>
#else
#include "util_sndfile.h"
#endif

#include "rubberband/RubberBandStretcher.h"

// declaration of chugin constructor
CK_DLL_CTOR(warpbuf_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(warpbuf_dtor);

// functions
CK_DLL_MFUN(warpbuf_read);
CK_DLL_MFUN(warpbuf_settimeratio);
CK_DLL_MFUN(warpbuf_setpitchscale);
CK_DLL_MFUN(warpbuf_setloopenable);

// multi-channel audio synthesis tick function
CK_DLL_TICKF(warpbuf_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT warpbuf_data_offset = 0;

//-----------------------------------------------------------------------------
// name: class WarpBufChugin
// desc: WarpBufChugin for time-stretching and pitch-stretching (via Rubberband library)
//-----------------------------------------------------------------------------
class WarpBufChugin
{
public:
    // constructor
    WarpBufChugin(t_CKFLOAT srate)
    {
        // sample rate
        m_srate = srate;

        using namespace RubberBand;

        RubberBandStretcher::Options options = 0;
        //options |= RubberBandStretcher::OptionProcessRealTime;
        options |= RubberBandStretcher::OptionStretchPrecise;
        //options |= RubberBandStretcher::OptionPhaseIndependent;
        //options |= RubberBandStretcher::OptionWindowLong;
        //options |= RubberBandStretcher::OptionWindowShort;
        //options |= RubberBandStretcher::OptionSmoothingOn;
        //options |= RubberBandStretcher::OptionFormantPreserved;
        options |= RubberBandStretcher::OptionPitchHighQuality;
        //options |= RubberBandStretcher::OptionChannelsTogether;

        // Pick one of these:
        options |= RubberBandStretcher::OptionThreadingAuto;
        //options |= RubberBandStretcher::OptionThreadingNever;
        //options |= RubberBandStretcher::OptionThreadingAlways;

        // Pick one of these:
        options |= RubberBandStretcher::OptionTransientsSmooth;
        //options |= RubberBandStretcher::OptionTransientsMixed;
        //options |= RubberBandStretcher::OptionTransientsCrisp;

        // Pick one of these:
        options |= RubberBandStretcher::OptionDetectorCompound;
        //options |= RubberBandStretcher::OptionDetectorPercussive;
        //options |= RubberBandStretcher::OptionDetectorSoft;

        m_rbstretcher = std::make_unique<RubberBand::RubberBandStretcher>(
            m_srate,
            2,
            options,
            1.,
            1.);

        m_nonInterleavedBuffer = new float * [channels];
        for (int i = 0; i < channels; i++) {
            m_nonInterleavedBuffer[i] = new float[ibs];
        }
        m_interleavedBuffer = new float[channels * ibs];

    }

    ~WarpBufChugin()
    {
        delete myChuckString;

        clearBufs();
        delete[] m_interleavedBuffer;

        if (m_nonInterleavedBuffer != NULL)
        {
            for (int i = 0; i < channels; i++)
                SAFE_DELETE_ARRAY(m_nonInterleavedBuffer[i]);
        }
        SAFE_DELETE_ARRAY(m_nonInterleavedBuffer);

        m_rbstretcher.release();
    }

    // for Chugins extending UGen
    void tick(SAMPLE* in, SAMPLE* out, int nframes);

    void setPitchScale(double scale);
    void setTimeRatio(double ratio);
    void setLoopEnable(bool enable);

    bool read(const string& filename);
    const int ibs = 1024;
    const int channels = 2;

private:
    // sample rate
    t_CKFLOAT m_srate;

    std::unique_ptr<RubberBand::RubberBandStretcher> m_rbstretcher;

    bool m_loopEnabled = true;

    float** m_retrieveBuffer = NULL; // non interleaved: [channels][ibs]
    float* m_interleavedBuffer = nullptr;  // interleaved: [channels*ibs]
    float** m_nonInterleavedBuffer = NULL;  // non interleaved: [channels][ibs]
    SNDFILE* sndfile;
    SF_INFO sfinfo;

    int numAllocated = 0;

    void clearBufs();
    void allocate(int numSamples);

protected:

    Chuck_String* myChuckString = new Chuck_String("");

};

void WarpBufChugin::setLoopEnable(bool enable) {
    m_loopEnabled = enable;
}

// clear
void WarpBufChugin::clearBufs()
{
    if (m_retrieveBuffer != NULL)
    {
        for (int i = 0; i < channels; i++)
            SAFE_DELETE_ARRAY(m_retrieveBuffer[i]);
    }
    SAFE_DELETE_ARRAY(m_retrieveBuffer);
}

// allocate
void WarpBufChugin::allocate(int numSamples)
{
    if (numAllocated == numSamples) {
        return;
    }
    numAllocated = numSamples;

    // clear
    clearBufs();

    m_retrieveBuffer = new float * [channels];
    // allocate buffers for each channel
    for (int i = 0; i < 2; i++)
    {
        // single sample for each
        m_retrieveBuffer[i] = new float[numSamples];
    }
}

void WarpBufChugin::setPitchScale(double scale) {
    m_rbstretcher->setPitchScale(scale);
}
void WarpBufChugin::setTimeRatio(double ratio) {
    m_rbstretcher->setTimeRatio(ratio);
}

void WarpBufChugin::tick(SAMPLE* in, SAMPLE* out, int nframes)
{
    allocate(nframes);

    size_t countIn = 0;

    int count = -1;
    int frame = 0;
    int numAvailable = m_rbstretcher->available();

    while (numAvailable < nframes) {

        if ((count = sf_readf_float(sndfile, m_interleavedBuffer, ibs)) <= 0) {
            sf_seek(sndfile, 0, SEEK_SET);
            count = sf_readf_float(sndfile, m_interleavedBuffer, ibs);
        }

        countIn += count;

        for (size_t c = 0; c < channels; ++c) {
            for (int i = 0; i < count; ++i) {
                float value = m_interleavedBuffer[i * channels + c];
                m_nonInterleavedBuffer[c][i] = value;
            }
        }

        bool final = (frame + ibs >= sfinfo.frames);

        m_rbstretcher->process(m_nonInterleavedBuffer, count, final);
        numAvailable = m_rbstretcher->available();
    }

    m_rbstretcher->retrieve(m_retrieveBuffer, nframes);

    //// copy from buffer to output.
    // out needs to receive alternating left/right channels.
    for (int chan = 0; chan < channels; chan++) {
        auto chanPtr = m_retrieveBuffer[chan];
        for (int i = 0; i < nframes; i++)
        {
            out[chan + 2 * i] = *chanPtr++;
        }
    }
}

bool WarpBufChugin::read(const string& path) {
    memset(&sfinfo, 0, sizeof(SF_INFO));

    sndfile = sf_open(path.c_str(), SFM_READ, &sfinfo);
    if (!sndfile) {
        cerr << "ERROR: Failed to open input file \"" << path << "\": "
            << sf_strerror(sndfile) << endl;
        return false;
    }

    if (sfinfo.samplerate == 0) {
        cerr << "ERROR: File lacks sample rate in header" << endl;
        return false;
    }

    //if (duration != 0.0) {
    //    if (sfinfo.frames == 0) {
    //        cerr << "ERROR: File lacks frame count in header, cannot use --duration" << endl;
    //        return 1;
    //    }
    //    double induration = double(sfinfo.frames) / double(sfinfo.samplerate);
    //    if (induration != 0.0) ratio = duration / induration;
    //}

    int channels = 2;
    int ibs = 1024;

    m_rbstretcher->setExpectedInputDuration(sfinfo.frames);

    int frame = 0;
    int percent = 0;

    sf_seek(sndfile, 0, SEEK_SET);

    if (true) {

        while (frame < sfinfo.frames) {

            int count = -1;

            if ((count = sf_readf_float(sndfile, m_interleavedBuffer, ibs)) <= 0) break;

            for (size_t c = 0; c < channels; ++c) {
                for (int i = 0; i < count; ++i) {
                    float value = m_interleavedBuffer[i * channels + c];
                    m_nonInterleavedBuffer[c][i] = value;
                }
            }

            bool final = (frame + ibs >= sfinfo.frames);

            m_rbstretcher->study(m_nonInterleavedBuffer, count, final);

            int p = int((double(frame) * 100.0) / sfinfo.frames);
            if (p > percent || frame == 0) {
                percent = p;
            }

            frame += ibs;
        }

        sf_seek(sndfile, 0, SEEK_SET);
    }

    // todo:
    //std::map<size_t, size_t> mapping;
    //if (!mapping.empty()) {
    //    m_rbstretcher->setKeyFrameMap(mapping);
    //}    

    return true;
}
//-----------------------------------------------------------------------------
// query function: chuck calls this when loading the Chugin
//-----------------------------------------------------------------------------
CK_DLL_QUERY( WarpBuf )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "WarpBuf");

    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "WarpBuf", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, warpbuf_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, warpbuf_dtor);

    // stereo out
    QUERY->add_ugen_funcf(QUERY, warpbuf_tick, NULL, 1, 2);

    QUERY->add_mfun(QUERY, warpbuf_read, "int", "read");
    QUERY->add_arg(QUERY, "string", "filename");

    QUERY->add_mfun(QUERY, warpbuf_setpitchscale, "int", "setPitchScale");
    QUERY->add_arg(QUERY, "float", "scale");

    QUERY->add_mfun(QUERY, warpbuf_settimeratio, "int", "setTimeRatio");
    QUERY->add_arg(QUERY, "float", "ratio");

    QUERY->add_mfun(QUERY, warpbuf_setloopenable, "int", "setLoopEnable");
    QUERY->add_arg(QUERY, "float", "enable");

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    warpbuf_data_offset = QUERY->add_mvar(QUERY, "int", "@b_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}

// implementation for the constructor
CK_DLL_CTOR(warpbuf_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, warpbuf_data_offset) = 0;

    // instantiate our internal c++ class representation
    WarpBufChugin * b_obj = new WarpBufChugin(API->vm->get_srate(API, SHRED));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, warpbuf_data_offset) = (t_CKINT) b_obj;
}

// implementation for the destructor
CK_DLL_DTOR(warpbuf_dtor)
{
    // get our c++ class pointer
    WarpBufChugin * b_obj = (WarpBufChugin *) OBJ_MEMBER_INT(SELF, warpbuf_data_offset);
    // check it
    if( b_obj )
    {
        // clean up
        delete b_obj;
        OBJ_MEMBER_INT(SELF, warpbuf_data_offset) = 0;
        b_obj = NULL;
    }
}

// implementation for tick function
CK_DLL_TICKF(warpbuf_tick)
{
    // get our c++ class pointer
    WarpBufChugin* b = (WarpBufChugin*)OBJ_MEMBER_INT(SELF, warpbuf_data_offset);

    // invoke our tick function; store in the magical out variable
    if (b) b->tick(in, out, nframes);

    // yes
    return TRUE;
}

CK_DLL_MFUN(warpbuf_read)
{
    string filename = GET_NEXT_STRING_SAFE(ARGS);

    WarpBufChugin* b = (WarpBufChugin*)OBJ_MEMBER_INT(SELF, warpbuf_data_offset);
    
    RETURN->v_int = b->read(filename.c_str());
}

CK_DLL_MFUN(warpbuf_settimeratio)
{
    t_CKFLOAT ratio = GET_NEXT_FLOAT(ARGS);

    WarpBufChugin* b = (WarpBufChugin*)OBJ_MEMBER_INT(SELF, warpbuf_data_offset);
    b->setTimeRatio(ratio);
    RETURN->v_int = true;
}

CK_DLL_MFUN(warpbuf_setpitchscale)
{
    t_CKFLOAT scale = GET_NEXT_FLOAT(ARGS);

    WarpBufChugin* b = (WarpBufChugin*)OBJ_MEMBER_INT(SELF, warpbuf_data_offset);
    b->setPitchScale(scale);
    RETURN->v_int = true;
}

CK_DLL_MFUN(warpbuf_setloopenable)
{
    t_CKBOOL enable = GET_NEXT_FLOAT(ARGS);

    WarpBufChugin* b = (WarpBufChugin*)OBJ_MEMBER_INT(SELF, warpbuf_data_offset);
    b->setLoopEnable(enable);
    RETURN->v_int = true;
}