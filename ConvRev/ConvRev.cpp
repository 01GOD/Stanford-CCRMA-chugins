//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// NOTE by default, chuginate generates a new UGen subclass in this file
//      but it is possible, of course, to create non-UGen classes in a chugin!
// To modify this generated file for a non-UGen class...
//      1. in QUERY->begin_class(), change "UGen" to a different ChucK class
//         (e.g., `QUERY->begin_class(QUERY, "ConvRev", "Object");`)
//      2. remove or commment out the line containing QUERY->add_ugen_func()
//      3. that's it; the rest is no different for UGens/non-UGens
//-----------------------------------------------------------------------------
// NOTE once you have built this into a chugin (ConvRev.chug), here are a few
//      helpful tools for testing / probing / verifying your new chugin!
//
// chuginate also generated a ConvRev-test.ck boilerplate ChucK program
//      to help test your chugin (see ConvRev-test.ck for more instructions)
//
// run `chuck --chugin-probe` to probe what chugins would be loaded, and
//      from where in the chugin search paths
//
// run `chuck -v3 --loop` to see what chugins are actually loaded at runtime,
//      with more info and error reporting than with --chugin-probe
//
// other helpful chugin-related flags include:
//      --chugin:<filename>
//      --chugin-path:(path) / -G(path)
//      --chugin-load:{on/off}
//
// for more information on command-line options:
// https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
// https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------

// include chuck dynamic linking header
#include "chuck_dl.h"

// vendor includes
#include "FFTConvolver.h"
#include "Utilities.h"

// general includes
#include <iostream>
#include <mutex>
#include <thread>

#define CONV_REV_BLOCKSIZE 128  // default FFT blocksize

// declaration of chugin constructor
CK_DLL_CTOR(convrev_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(convrev_dtor);

// example of getter/setter
CK_DLL_MFUN(convrev_setBlockSize);
CK_DLL_MFUN(convrev_getBlockSize);

// Set order of IR buffer
CK_DLL_MFUN(convrev_setOrder);
CK_DLL_MFUN(convrev_getOrder);

// populate individual IR sample values
CK_DLL_MFUN(convrev_setCoeff);
CK_DLL_MFUN(convrev_getCoeff);

CK_DLL_MFUN(convrev_init);  // initialize convolution engine

// load entire buffer at once  (see fluidsynth for how to take in array arg)
// CK_DLL_MFUN(convrev_setIRBuffer);
// Problems: no way to return an array, no way to get an array from sndbuf ugen

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(convrev_tick);

// this is a special offset reserved for chugin internal data
t_CKINT convrev_data_offset = 0;


// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but serves as example of one recommended approach)
class ConvRev
{
public:
    // constructor
    ConvRev( t_CKFLOAT fs)
    {
        _SR = fs;
        _blocksize = CONV_REV_BLOCKSIZE;
        _order = 0;
        _ir_buffer = new float[0];
        _tmp = 0;
        _convolver = new fftconvolver::FFTConvolver();
        _idx = 0;
        _total = 0;
        _joined = false;
        _scale_factor = 1;
    }

    ~ConvRev()
    {
        delete[] _ir_buffer;
        delete[] _input_buffer;
        delete[] _output_buffer;
        delete[] _staging_in_buffer;
        delete[] _staging_out_buffer;
        delete _convolver;
        _conv_thr.join();
    }

    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        // default: this passes whatever input is patched into Chugin
        ++_total;
        _input_buffer[_idx++] = static_cast<fftconvolver::Sample>(in);
        if (_idx == _blocksize) {
          _idx = 0; // reset circular buffer head

          if (_joined) {
            _conv_thr.join();
          } else { _joined = true; }

          std::lock_guard<std::mutex> guard(_staging_mutex);
          memset(_staging_in_buffer, 0, _blocksize * sizeof(fftconvolver::Sample));  // zero the staging buffer
          memcpy(_staging_in_buffer, _input_buffer, _blocksize * sizeof(fftconvolver::Sample)); // copy current input buffer contents

          memset(_output_buffer, 0, _blocksize * sizeof(fftconvolver::Sample));  // zero the staging buffer
          memcpy(_output_buffer, _staging_out_buffer, _blocksize * sizeof(fftconvolver::Sample)); // copy current input buffer contents

          _conv_thr = std::thread(&ConvRev::_process, this); // start processing the new input block
        }
        return _scale_factor * static_cast<SAMPLE>(_output_buffer[_idx]);
    }

    void _process() {
      std::lock_guard<std::mutex> guard(_staging_mutex);
      _convolver->process(_staging_in_buffer, _staging_out_buffer, _blocksize);
    }

    // set parameter example
    t_CKFLOAT setBlockSize( t_CKFLOAT p )
    {
        _blocksize = p;
        return p;
    }

    // get parameter example
    t_CKFLOAT getBlockSize() { return _blocksize; }

    t_CKINT setOrder( t_CKINT m )
    {

        delete[] _ir_buffer;

        _ir_buffer = new float[m];

        for (int i = 0; i < m; i++)  {
            _ir_buffer[i] = 0.0;
        }

        _order = m;

        return _order;
    }

    t_CKINT getOrder() {
      return _order;
    }

    t_CKFLOAT setCoeff(t_CKINT idx, t_CKFLOAT val) {
      if (idx >= _order) {
        printf("illegal idx out of bounds, idx = %li on size %li\n", idx, _order);
        return val;
      }
      _ir_buffer[idx] = val;
      return val;
    }
    t_CKFLOAT getCoeff(t_CKINT idx) { return _ir_buffer[idx]; }

    t_CKVOID init() {
      _input_buffer = new fftconvolver::Sample[_blocksize];
      _output_buffer = new fftconvolver::Sample[_blocksize];
      _staging_in_buffer = new fftconvolver::Sample[_blocksize];
      _staging_out_buffer = new fftconvolver::Sample[_blocksize];
      _convolver->init(_blocksize, _ir_buffer, _order);
      _scale_factor = 44100. / _order;
      if (_scale_factor > 1) { _scale_factor = 1; }

    }

private:
    // instance data
    t_CKINT _blocksize;
    t_CKFLOAT _SR;
    t_CKINT _order;
    int _tmp;
    float *_ir_buffer;
    fftconvolver::FFTConvolver *_convolver;
    fftconvolver::Sample *_input_buffer;
    fftconvolver::Sample *_staging_in_buffer;
    fftconvolver::Sample *_staging_out_buffer;
    fftconvolver::Sample *_output_buffer;
    size_t _idx;  // to track head of circular input buffer
    size_t _total; // how many samples have we processed total
    std::thread _conv_thr;
    std::mutex _staging_mutex;  // lock on _staging buffers
    bool _joined;
    float _scale_factor;
};


// query function: chuck calls this when loading the chugin
// (NOTE developer will need to modify this function to add additional functions to this chugin)
CK_DLL_QUERY( ConvRev )
{
    // hmm, don't change this...
    QUERY->setname( QUERY, "ConvRev" );
    
    // begin the class definition
    // NOTE to create a non-UGen class, change the second argument
    // to extend a different ChucK class (e.g., "Object")
    QUERY->begin_class( QUERY, "ConvRev", "UGen" );

    // register the constructor (probably no need to change)
    QUERY->add_ctor( QUERY, convrev_ctor );
    // register the destructor (probably no need to change)
    QUERY->add_dtor( QUERY, convrev_dtor );

    // for UGens only: add tick function
    // NOTE a non-UGen class should remove or comment out this next line
    QUERY->add_ugen_func( QUERY, convrev_tick, NULL, 1, 1 );
    // NOTE: if this is to be a UGen with more than 1 channel,
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    // example of adding setter method
    QUERY->add_mfun(QUERY, convrev_setBlockSize, "float", "blocksize");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding getter method
    QUERY->add_mfun(QUERY, convrev_getBlockSize, "float", "blocksize");


    QUERY->add_mfun(QUERY, convrev_setOrder, "int", "order");
    QUERY->add_arg(QUERY, "int", "arg");

    QUERY->add_mfun(QUERY, convrev_getOrder, "int", "order");


    QUERY->add_mfun(QUERY, convrev_setCoeff, "float", "coeff");
    QUERY->add_arg(QUERY, "int", "arg");
    QUERY->add_arg(QUERY, "float", "arg2");

    QUERY->add_mfun(QUERY, convrev_getCoeff, "float", "coeff");
    QUERY->add_arg(QUERY, "int", "arg");

    QUERY->add_mfun(QUERY, convrev_init, "void", "init");

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    convrev_data_offset = QUERY->add_mvar(QUERY, "int", "@cr_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(convrev_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, convrev_data_offset) = 0;

    // instantiate our internal c++ class representation
    ConvRev * cr_obj = new ConvRev(API->vm->srate(VM));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, convrev_data_offset) = (t_CKINT) cr_obj;

    // SSE enabled
    std::cout << fftconvolver::SSEEnabled() << std::endl;
}


// implementation for the destructor
CK_DLL_DTOR(convrev_dtor)
{
    // get our c++ class pointer
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    // check it
    if( cr_obj )
    {
        // clean up
        delete cr_obj;
        OBJ_MEMBER_INT(SELF, convrev_data_offset) = 0;
        cr_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(convrev_tick)
{
    // get our c++ class pointer
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);

    // invoke our tick function; store in the magical out variable
    if(cr_obj) *out = cr_obj->tick(in);

    // yes
    return TRUE;
}


// example implementation for setter
CK_DLL_MFUN(convrev_setBlockSize)
{
    // get our c++ class pointer
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    // set the return value
    RETURN->v_float = cr_obj->setBlockSize(GET_NEXT_FLOAT(ARGS));
}


// example implementation for getter
CK_DLL_MFUN(convrev_getBlockSize)
{
    // get our c++ class pointer
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    // set the return value
    RETURN->v_float = cr_obj->getBlockSize();
}

CK_DLL_MFUN(convrev_setOrder)
{
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    RETURN->v_int = cr_obj->setOrder(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(convrev_getOrder)
{
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    RETURN->v_int = cr_obj->getOrder();
}


CK_DLL_MFUN(convrev_setCoeff)
{
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    t_CKINT idx = GET_NEXT_INT(ARGS);
    t_CKFLOAT val = GET_NEXT_FLOAT(ARGS);
    RETURN->v_int = cr_obj->setCoeff(idx, val);
}

CK_DLL_MFUN(convrev_getCoeff)
{
    ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
    RETURN->v_int = cr_obj->getCoeff(GET_CK_INT(ARGS));
}

CK_DLL_MFUN(convrev_init)
{
  ConvRev * cr_obj = (ConvRev *) OBJ_MEMBER_INT(SELF, convrev_data_offset);
  cr_obj->init();
}
