//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>

// declaration of chugin constructor
CK_DLL_CTOR(scaler_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(scaler_dtor);

// example of getter/setter
CK_DLL_MFUN(scaler_setParam);
CK_DLL_MFUN(scaler_getParam);
CK_DLL_MFUN(scaler_setInRange);
CK_DLL_MFUN(scaler_setInRadius);
CK_DLL_MFUN(scaler_setOutRange);
CK_DLL_MFUN(scaler_setOutRadius);
CK_DLL_MFUN(scaler_set);
CK_DLL_MFUN(scaler_setRadius);

CK_DLL_MFUN(scaler_getInMin);
CK_DLL_MFUN(scaler_getInMax);
CK_DLL_MFUN(scaler_getOutMin);
CK_DLL_MFUN(scaler_getOutMax);
CK_DLL_MFUN(scaler_getInCenter);
CK_DLL_MFUN(scaler_getInRadius);
CK_DLL_MFUN(scaler_getOutCenter);
CK_DLL_MFUN(scaler_getOutRadius);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(scaler_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT scaler_data_offset = 0;


// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
class Scaler
{
public:
    // constructor
    Scaler( t_CKFLOAT fs)
    {
        m_param = 0;
        m_in_min = -1;
        m_in_max = 1;
        m_out_min = 0;
        m_out_max = 1;
    }

    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        SAMPLE out = (in - m_in_min) / (m_in_max - m_in_min);
        out = out * (m_out_max - m_out_min) + m_out_min;

        // default: this passes whatever input is patched into Chugin
        return out;
    }

    // set parameter example
    t_CKFLOAT setParam( t_CKFLOAT p )
    {
        m_param = p;
        return p;
    }

    t_CKVOID setInRange( t_CKFLOAT in_min, t_CKFLOAT in_max ) {
        m_in_min = in_min;
        m_in_max = in_max;
    }

    t_CKVOID setInRadius( t_CKFLOAT in_center, t_CKFLOAT in_radius ) {
        m_in_min = in_center - in_radius;
        m_in_max = in_center + in_radius;
    }

    t_CKVOID setOutRange( t_CKFLOAT out_min, t_CKFLOAT out_max ) {
        m_out_min = out_min;
        m_out_max = out_max;
    }

    t_CKVOID setOutRadius( t_CKFLOAT out_center, t_CKFLOAT out_radius ) {
        m_out_min = out_center - out_radius;
        m_out_max = out_center + out_radius;
    }

    t_CKVOID set( t_CKFLOAT in_min, t_CKFLOAT in_max, t_CKFLOAT out_min, t_CKFLOAT out_max ) {
        m_in_min = in_min;
        m_in_max = in_max;
        m_out_min = out_min;
        m_out_max = out_max;
    }

    t_CKVOID setRadius(t_CKFLOAT in_center, t_CKFLOAT in_radius, t_CKFLOAT out_center, t_CKFLOAT out_radius) {
        m_in_min = in_center - in_radius;
        m_in_max = in_center + in_radius;
        m_out_min = out_center - out_radius;
        m_out_max = out_center + out_radius;
    }

    // get parameter example
    t_CKFLOAT getParam() { return m_param; }
    t_CKFLOAT getInMin() { return m_in_min; }
    t_CKFLOAT getInMax() { return m_in_max; }
    t_CKFLOAT getOutMin() { return m_out_min; }
    t_CKFLOAT getOutMax() { return m_out_max; }

    t_CKFLOAT getInCenter() { return (m_in_min + m_in_max) / 2; }
    t_CKFLOAT getInRadius() { return (m_in_max - m_in_min) / 2; }
    t_CKFLOAT getOutCenter() { return (m_out_min + m_out_max) / 2; }
    t_CKFLOAT getOutRadius() { return (m_out_max - m_out_min) / 2; }


private:
    // instance data
    t_CKFLOAT m_param;
    t_CKFLOAT m_in_min, m_in_max, m_out_min, m_out_max;
    // t_CKFLOAT m_in_center, m_in_radius, m_out_center, m_out_radius; // just use these in methods
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( Scaler )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "Scaler");
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "Scaler", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, scaler_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, scaler_dtor);
    
    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, scaler_tick, NULL, 1, 1);
    
    // NOTE: if this is to be a UGen with more than 1 channel, 
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    // example of adding setter method
    QUERY->add_mfun(QUERY, scaler_setParam, "float", "param");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding getter method
    QUERY->add_mfun(QUERY, scaler_getParam, "float", "param");
    
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    scaler_data_offset = QUERY->add_mvar(QUERY, "int", "@s_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(scaler_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, scaler_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    Scaler * s_obj = new Scaler(API->vm->get_srate(API, SHRED));
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, scaler_data_offset) = (t_CKINT) s_obj;
}


// implementation for the destructor
CK_DLL_DTOR(scaler_dtor)
{
    // get our c++ class pointer
    Scaler * s_obj = (Scaler *) OBJ_MEMBER_INT(SELF, scaler_data_offset);
    // check it
    if( s_obj )
    {
        // clean up
        delete s_obj;
        OBJ_MEMBER_INT(SELF, scaler_data_offset) = 0;
        s_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(scaler_tick)
{
    // get our c++ class pointer
    Scaler * s_obj = (Scaler *) OBJ_MEMBER_INT(SELF, scaler_data_offset);
 
    // invoke our tick function; store in the magical out variable
    if(s_obj) *out = s_obj->tick(in);

    // yes
    return TRUE;
}


// example implementation for setter
CK_DLL_MFUN(scaler_setParam)
{
    // get our c++ class pointer
    Scaler * s_obj = (Scaler *) OBJ_MEMBER_INT(SELF, scaler_data_offset);
    // set the return value
    RETURN->v_float = s_obj->setParam(GET_NEXT_FLOAT(ARGS));
}


// example implementation for getter
CK_DLL_MFUN(scaler_getParam)
{
    // get our c++ class pointer
    Scaler * s_obj = (Scaler *) OBJ_MEMBER_INT(SELF, scaler_data_offset);
    // set the return value
    RETURN->v_float = s_obj->getParam();
}
